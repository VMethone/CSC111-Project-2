# -*- coding: utf-8 -*-
"""Flight Datavisualization

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fSTG9sU0qSxnsjfKwGG4VSVZgdC5GyIL
"""

import pandas as pd

# Replace this with the actual path to the CSV file
csv_file_path = "/content/sample_data/US Airline Flight Routes and Fares 1993-2024 2.csv"

# Read the CSV into a pandas DataFrame
df = pd.read_csv(csv_file_path)


df.head()

# Define a function to categorize the year
def categorize_period(year):
    if 2018 <= year <= 2020:
        return "Pre-Pandemic"
    elif 2021 <= year <= 2022:
        return "During-Pandemic"
    elif 2023 <= year <= 2024:
        return "Post-Pandemic"
    else:
        return "Other"

# Apply the function to create a new column
df['period'] = df['Year'].apply(categorize_period)

# Apply the function to create a new column
df['period'] = df['Year'].apply(categorize_period)

# Keep only the defined periods (drop "Other")
df = df[df['period'] != 'Other']

# Sort the DataFrame by Year and Quarter
df = df.sort_values(by=['Year', 'quarter']).reset_index(drop=True)

# Step 1: Create a lookup dictionary from rows where geocoded data exists
geo_lookup = df.dropna(subset=['Geocoded_City1', 'Geocoded_City2']) \
               .drop_duplicates(subset=['city1', 'city2']) \
               .set_index(['city1', 'city2'])[['Geocoded_City1', 'Geocoded_City2']]

# Step 2: Define a function to fill missing geocoded values using the lookup
def fill_geocodes(row):
    if pd.isna(row['Geocoded_City1']) or pd.isna(row['Geocoded_City2']):
        key = (row['city1'], row['city2'])
        if key in geo_lookup.index:
            if pd.isna(row['Geocoded_City1']):
                row['Geocoded_City1'] = geo_lookup.loc[key, 'Geocoded_City1']
            if pd.isna(row['Geocoded_City2']):
                row['Geocoded_City2'] = geo_lookup.loc[key, 'Geocoded_City2']
    return row

# Step 3: Apply the function to the whole DataFrame
df = df.apply(fill_geocodes, axis=1)

# --- Step 1: Define what a valid geocode is (must include city + coordinates)
def is_valid_geocode(val):
    return isinstance(val, str) and "," in val and "(" in val and ")" in val and not val.strip().startswith("(")

# --- Step 2: Create lookup from only valid geocoded entries
valid_geo = df[
    df['Geocoded_City1'].apply(is_valid_geocode) &
    df['Geocoded_City2'].apply(is_valid_geocode)
]

# Build lookup dictionary based on (city1, city2) pairs
geo_lookup = valid_geo.drop_duplicates(subset=['city1', 'city2']) \
                      .set_index(['city1', 'city2'])[['Geocoded_City1', 'Geocoded_City2']]

# --- Step 3: Function to fill in both missing and incomplete geocodes
def fill_geocodes(row):
    key = (row['city1'], row['city2'])

    if key in geo_lookup.index:
        # Fill if missing or incomplete
        if not is_valid_geocode(row['Geocoded_City1']):
            row['Geocoded_City1'] = geo_lookup.loc[key, 'Geocoded_City1']
        if not is_valid_geocode(row['Geocoded_City2']):
            row['Geocoded_City2'] = geo_lookup.loc[key, 'Geocoded_City2']

    return row

# --- Step 4: Apply to entire DataFrame
df = df.apply(fill_geocodes, axis=1)

# --- Step 5 (Optional): Check remaining bad rows
bad_rows = df[
    df['Geocoded_City1'].apply(lambda x: not is_valid_geocode(x)) |
    df['Geocoded_City2'].apply(lambda x: not is_valid_geocode(x))
]
print(f"Remaining incomplete geocoded rows: {len(bad_rows)}")

# Define what is a complete geocode again (city + coordinates)
def is_valid_geocode(val):
    return isinstance(val, str) and "," in val and "(" in val and ")" in val and not val.strip().startswith("(")

# Filter to keep only rows where both geocode fields are valid
df = df[
    df['Geocoded_City1'].apply(is_valid_geocode) &
    df['Geocoded_City2'].apply(is_valid_geocode)
]

# (Optional) Reset index after filtering
df.reset_index(drop=True, inplace=True)

# (Optional) Save cleaned data
df.to_csv("fully_cleaned_geocoded_airline_data.csv", index=False)

# Confirm it's clean
print("Remaining incomplete geocoded rows:", df[
    df['Geocoded_City1'].apply(lambda x: not is_valid_geocode(x)) |
    df['Geocoded_City2'].apply(lambda x: not is_valid_geocode(x))
].shape[0])

df

df = df.drop(columns=['tbl'])

df.to_csv("filled_geocoded_airline_data.csv", index=False)

# Combine city1 and city2 into a single set of unique cities
unique_cities = pd.concat([df['city1'], df['city2']]).unique()

# Print the total number of unique cities
print(f"Total number of unique cities: {len(unique_cities)}")

# (Optional) To view the list of cities
# print(sorted(unique_cities))

import networkx as nx
import matplotlib.pyplot as plt

# Create a directed graph (or use nx.Graph() for undirected)
G = nx.Graph()

# Add nodes: use city names
cities = pd.concat([df['city1'], df['city2']]).unique()
G.add_nodes_from(cities)

# Add edges with attributes: fare and distance
for _, row in df.iterrows():
    origin = row['city1']
    destination = row['city2']
    fare = row['fare']
    distance = row['nsmiles']

    # Add edge with both fare and distance as attributes
    G.add_edge(origin, destination, fare=fare, distance=distance)

# Draw the graph (simplified layout for now)
plt.figure(figsize=(14, 10))
pos = nx.spring_layout(G, seed=42, k=0.3)  # force-directed layout
nx.draw_networkx_nodes(G, pos, node_size=50)
nx.draw_networkx_edges(G, pos, alpha=0.3)
nx.draw_networkx_labels(G, pos, font_size=6)
plt.title("Airline Route Network (Nodes = Cities, Edges = Routes)")
plt.axis('off')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import networkx as nx

# Prepare a figure with 7 subplots (one for each year from 2018 to 2024)
years = list(range(2018, 2025))
fig, axes = plt.subplots(nrows=2, ncols=4, figsize=(20, 12))
axes = axes.flatten()

for i, year in enumerate(years):
    # Create a new graph for each year
    G_year = nx.Graph()
    df_year = df[df['Year'] == year]

    # Add nodes
    cities_year = pd.concat([df_year['city1'], df_year['city2']]).unique()
    G_year.add_nodes_from(cities_year)

    # Add edges with attributes
    for _, row in df_year.iterrows():
        origin = row['city1']
        destination = row['city2']
        fare = row['fare']
        distance = row['nsmiles']
        G_year.add_edge(origin, destination, fare=fare, distance=distance)

    # Generate layout and draw
    pos = nx.spring_layout(G_year, seed=42, k=0.3)
    ax = axes[i]
    nx.draw_networkx_nodes(G_year, pos, node_size=40, ax=ax)
    nx.draw_networkx_edges(G_year, pos, alpha=0.3, ax=ax)
    nx.draw_networkx_labels(G_year, pos, font_size=5, ax=ax)
    ax.set_title(f"Airline Network - {year}")
    ax.axis('off')

# Hide the unused subplot if any (8th subplot)
if len(years) < len(axes):
    for j in range(len(years), len(axes)):
        axes[j].axis('off')

plt.tight_layout()
plt.show()

# Create 28 subplots (7 years Ã— 4 quarters = 28)
fig, axes = plt.subplots(nrows=7, ncols=4, figsize=(24, 28))
axes = axes.flatten()

plot_idx = 0

for year in range(2018, 2025):  # 2018 to 2024
    for quarter in range(1, 5):  # Q1 to Q4
        # Filter data for the specific year and quarter
        df_sub = df[(df['Year'] == year) & (df['quarter'] == quarter)]

        # Create a new graph for this quarter
        G_sub = nx.Graph()
        cities = pd.concat([df_sub['city1'], df_sub['city2']]).unique()
        G_sub.add_nodes_from(cities)

        for _, row in df_sub.iterrows():
            origin = row['city1']
            destination = row['city2']
            fare = row['fare']
            distance = row['nsmiles']
            G_sub.add_edge(origin, destination, fare=fare, distance=distance)

        # Draw the graph in the current subplot
        pos = nx.spring_layout(G_sub, seed=42, k=0.3)
        ax = axes[plot_idx]
        nx.draw_networkx_nodes(G_sub, pos, node_size=20, ax=ax)
        nx.draw_networkx_edges(G_sub, pos, alpha=0.3, ax=ax)
        nx.draw_networkx_labels(G_sub, pos, font_size=4, ax=ax)
        ax.set_title(f"{year} Q{quarter}")
        ax.axis('off')

        plot_idx += 1

plt.tight_layout()
plt.show()

import os
import networkx as nx
import matplotlib.pyplot as plt

# Create a folder to store the images
os.makedirs("airline_network_quarters", exist_ok=True)

for year in range(2018, 2025):
    for quarter in range(1, 5):
        df_sub = df[(df['Year'] == year) & (df['quarter'] == quarter)]

        G_sub = nx.Graph()
        cities = pd.concat([df_sub['city1'], df_sub['city2']]).unique()
        G_sub.add_nodes_from(cities)

        for _, row in df_sub.iterrows():
            G_sub.add_edge(
                row['city1'],
                row['city2'],
                fare=row['fare'],
                distance=row['nsmiles']
            )

        # Use force-directed layout with dynamic spacing
        pos = nx.spring_layout(G_sub, seed=42, k=1.2 / (len(G_sub.nodes()) + 1))

        # Plot
        plt.figure(figsize=(12, 10))
        nx.draw_networkx_nodes(G_sub, pos, node_size=40, node_color='cornflowerblue')
        nx.draw_networkx_edges(G_sub, pos, alpha=0.2, width=0.7, edge_color='gray')
        nx.draw_networkx_labels(G_sub, pos, font_size=5)

        plt.title(f"Airline Network - {year} Q{quarter}", fontsize=14)
        plt.axis('off')
        plt.tight_layout()
        plt.savefig(f"airline_network_quarters/network_{year}_Q{quarter}.png")
        plt.close()